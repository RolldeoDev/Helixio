// Helixio Database Schema
// SQLite database stored at ~/.helixio/helixio.db

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// =============================================================================
// Library Management
// =============================================================================

model Library {
  id        String   @id @default(cuid())
  name      String
  rootPath  String   @unique
  type      String   @default("western") // "western" | "manga"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  files           ComicFile[]
  batchOperations BatchOperation[]
  readerSettings  LibraryReaderSettings?
  entityStats     EntityStat[]
  libraryStat     LibraryStat?
  scanJobs        LibraryScanJob[]

  @@index([name])
}

// =============================================================================
// Series Management (Series-Centric Architecture)
// =============================================================================

model Series {
  id            String   @id @default(cuid())

  // Identity (unique constraint: name + publisher only - year not included to avoid splitting multi-year series)
  name          String                    // Series name (e.g., "Batman")
  startYear     Int?                      // Publication start year (for display, not identity)
  publisher     String?                   // Publisher name (shows primary/latest for multi-publisher)

  // Metadata
  summary       String?                   // Series description/summary
  deck          String?                   // Short description
  endYear       Int?                      // Publication end year (null if ongoing)
  volume        Int?                      // Volume number for multi-volume series
  issueCount    Int?                      // Known total issue count from API

  // Content classification
  genres        String?                   // Comma-separated genres
  tags          String?                   // Comma-separated tags
  ageRating     String?                   // Age rating
  type          String  @default("western") // "western" | "manga"
  languageISO   String?                   // Language code

  // Content entities (comma-separated)
  characters    String?
  teams         String?
  locations     String?
  storyArcs     String?
  creators      String?                   // Volume-level creators (no roles, from ComicVine volume.people)

  // Role-specific creators (comma-separated, for more granular tracking)
  writer        String?                   // Writers
  penciller     String?                   // Pencil artists
  inker         String?                   // Inkers
  colorist      String?                   // Colorists
  letterer      String?                   // Letterers
  coverArtist   String?                   // Cover artists
  editor        String?                   // Editors

  // Structured creator data aggregated from issues (JSON: { writer: ["Name"], penciller: ["Name"], ... })
  creatorsJson  String?

  // Creator display source preference: "api" = use API data, "issues" = aggregate from local issue metadata
  creatorSource String  @default("api")  // "api" | "issues"

  // Cover management (Smart Fallback: API > User > First Issue)
  coverSource   String  @default("auto")  // "api" | "user" | "auto"
  coverUrl      String?                   // API-provided cover URL (kept for reference/re-download)
  coverHash     String?                   // Hash of downloaded API cover (for local cache lookup)
  coverFileId   String?                   // User-selected cover from owned issue

  // External IDs
  comicVineId   String?
  metronId      String?
  anilistId     String?                   // AniList series ID
  malId         String?                   // MyAnimeList ID (auto-linked from AniList idMal)

  // File system reference
  primaryFolder String?                   // Primary folder path for series.json sync

  // User data (NOT synced to files)
  userNotes     String?

  // Aliases for fuzzy matching (comma-separated, e.g., "ASM,Amazing Spidey")
  aliases       String?

  // Custom reading order (JSON array of issue numbers/fileIds, null = default order)
  customReadingOrder String?

  // Field-level edit tracking (JSON: {"fieldName": {"source": "manual"|"api"|"file", "lockedAt": timestamp}})
  fieldSources  String?

  // Locked fields that won't be overwritten by API/file sync (comma-separated field names)
  lockedFields  String?

  // Tracking
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastSyncedAt  DateTime?

  // Soft delete support
  deletedAt     DateTime?  // Null = active, timestamp = soft-deleted

  // Visibility control (separate from soft-delete)
  isHidden      Boolean   @default(false)  // Hidden from browse lists, but accessible via search/links

  // Relations
  issues        ComicFile[]
  progress      SeriesProgress[]
  readerSettings SeriesReaderSettingsNew?

  // Parent/Child relationships (many-to-many)
  parentRelationships  SeriesRelationship[] @relation("ChildSeries")   // Series where this is the child
  childRelationships   SeriesRelationship[] @relation("ParentSeries")  // Series where this is the parent

  @@unique([name, publisher], name: "series_identity")
  @@index([isHidden])
  @@index([name])
  @@index([publisher])
  @@index([startYear])
  @@index([comicVineId])
  @@index([metronId])
  @@index([anilistId])
  @@index([malId])
}

// =============================================================================
// Series Relationships (Parent/Child, Many-to-Many)
// =============================================================================

model SeriesRelationship {
  id              String   @id @default(cuid())

  // Parent series (e.g., "Solo Leveling")
  parentSeriesId  String
  parentSeries    Series   @relation("ParentSeries", fields: [parentSeriesId], references: [id], onDelete: Cascade)

  // Child series (e.g., "Solo Leveling: Side Stories")
  childSeriesId   String
  childSeries     Series   @relation("ChildSeries", fields: [childSeriesId], references: [id], onDelete: Cascade)

  // Relationship metadata
  relationshipType String  @default("related") // "related" | "spinoff" | "prequel" | "sequel" | "bonus"
  sortOrder       Int      @default(0)         // Order within parent's related series

  createdAt       DateTime @default(now())

  @@unique([parentSeriesId, childSeriesId])
  @@index([parentSeriesId])
  @@index([childSeriesId])
}

// =============================================================================
// Series Progress (Cached reading progress for series)
// =============================================================================

model SeriesProgress {
  id               String   @id @default(cuid())
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  seriesId         String
  series           Series   @relation(fields: [seriesId], references: [id], onDelete: Cascade)

  // Calculated fields (cached for performance)
  totalOwned       Int      @default(0)
  totalRead        Int      @default(0)
  totalInProgress  Int      @default(0)

  // Continue reading support (Last Read +1 logic)
  lastReadFileId   String?              // Most recently read issue
  lastReadIssueNum Float?               // Issue number of last read (for +1 logic)
  lastReadAt       DateTime?
  nextUnreadFileId String?              // Calculated: issue after lastReadIssueNum

  @@unique([userId, seriesId])
  @@index([userId])
  @@index([seriesId])
  @@index([lastReadAt])
}

// =============================================================================
// Series Reader Settings (linked to Series entity)
// =============================================================================

model SeriesReaderSettingsNew {
  id              String   @id @default(cuid())
  seriesId        String   @unique
  series          Series   @relation(fields: [seriesId], references: [id], onDelete: Cascade)

  // Reading mode (null = inherit from library)
  readingMode     String?  // "single" | "continuous" | "webtoon"
  readingDirection String? // "ltr" | "rtl" (null = auto-detect from type)

  // Display settings (null = inherit)
  mode            String?  // "single" | "double" | "doubleManga" | "continuous"
  direction       String?  // "ltr" | "rtl" | "vertical"
  scaling         String?  // "fitHeight" | "fitWidth" | "fitScreen" | "original" | "custom"
  customWidth     Int?
  splitting       String?  // "none" | "ltr" | "rtl"
  background      String?  // "white" | "gray" | "black"
  brightness      Int?
  colorCorrection String?  // "none" | "sepia-correct" | "contrast-boost" | "desaturate" | "invert"
  showPageShadow  Boolean?
  autoHideUI      Boolean?
  preloadCount    Int?
  webtoonGap      Int?
  webtoonMaxWidth Int?

  // Origin tracking (informational - tracks which preset these settings came from)
  basedOnPresetId   String?
  basedOnPresetName String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([seriesId])
}

// =============================================================================
// Comic File Tracking
// =============================================================================

model ComicFile {
  id           String   @id @default(cuid())
  libraryId    String
  path         String   @unique // Full absolute path to the file
  relativePath String // Path relative to library root
  filename     String // Just the filename
  extension    String // "cbz" | "cbr"
  size         Int // File size in bytes
  modifiedAt   DateTime // File system modified date
  hash         String? // Partial hash for file matching (first/last N bytes)
  status       String   @default("pending") // "pending" | "indexed" | "orphaned" | "quarantined"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Series relationship (Series-Centric Architecture)
  seriesId     String?
  series       Series?  @relation(fields: [seriesId], references: [id], onDelete: SetNull)

  // Cover management (auto = first page, page = specific page, custom = URL/upload)
  coverSource    String  @default("auto")  // "auto" | "page" | "custom"
  coverPageIndex Int?                       // Page index if source is "page" (0-indexed)
  coverHash      String?                    // Hash of custom cover (URL/upload stored in series covers cache)
  coverUrl       String?                    // Original URL if cover was downloaded from URL

  // Relations
  library             Library               @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  metadata            FileMetadata?
  readingProgress     ReadingProgress?
  userReadingProgress UserReadingProgress[]
  readingQueue        ReadingQueue?
  readingHistory      ReadingHistory[]
  readerSettings      IssueReaderSettings?

  @@index([libraryId])
  @@index([hash])
  @@index([status])
  @@index([filename])
  @@index([seriesId])
}

// =============================================================================
// Original Filename Tracking (for templated rename undo support)
// =============================================================================

model OriginalFilename {
  id               String    @id @default(cuid())
  fileId           String    @unique
  originalFilename String               // Original filename before rename
  originalPath     String               // Original full path before rename
  renameHistory    String    @default("[]")  // JSON array of RenameHistoryEntry
  lastRenamedAt    DateTime?            // When the file was last renamed
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([fileId])
}

// =============================================================================
// API Keys (for programmatic access)
// =============================================================================

model ApiKey {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  name          String                   // User-friendly name for the key
  description   String?                  // Optional description
  keyPrefix     String                   // First 12 chars for identification (hlx_xxxxxxxx)
  keyHash       String    @unique        // HMAC-SHA256 hash of the full key
  scopes        String                   // JSON array of allowed scopes
  libraryIds    String?                  // JSON array of allowed library IDs (null = all)
  ipWhitelist   String?                  // JSON array of allowed IPs/CIDRs (null = no restriction)
  rateLimitTier String    @default("standard")  // "standard" | "elevated" | "unlimited"
  expiresAt     DateTime?                // Null = never expires
  isActive      Boolean   @default(true)
  lastUsedAt    DateTime?
  lastUsedIp    String?
  usageCount    Int       @default(0)
  revokedAt     DateTime?
  revokedReason String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  usageLogs     ApiKeyUsageLog[]

  @@index([userId])
  @@index([keyHash])
  @@index([isActive])
}

model ApiKeyUsageLog {
  id         String   @id @default(cuid())
  apiKeyId   String
  apiKey     ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)
  endpoint   String                    // API endpoint called
  method     String                    // HTTP method
  statusCode Int                       // HTTP response status
  ipAddress  String                    // Client IP address
  userAgent  String?                   // Client user agent
  durationMs Int?                      // Request duration in milliseconds
  timestamp  DateTime @default(now())

  @@index([apiKeyId])
  @@index([apiKeyId, timestamp])
  @@index([timestamp])
}

// =============================================================================
// Cached Metadata (from ComicInfo.xml)
// =============================================================================

model FileMetadata {
  id        String @id @default(cuid())
  comicId   String @unique

  // Core identification
  series      String?
  number      String? // Issue/volume number (string to handle "1.5", "Annual 1", etc.)
  issueNumberSort Float?  // Numeric sort key for proper ordering (null for non-numeric)
  title       String?
  volume      Int? // Volume number for multi-volume series

  // Publication info
  publisher   String?
  imprint     String?
  year        Int?
  month       Int?
  day         Int?

  // Creators (stored as comma-separated for simplicity, can be normalized later)
  writer      String?
  penciller   String?
  inker       String?
  colorist    String?
  letterer    String?
  coverArtist String?
  editor      String?
  creator     String?   // Generic creator (inherited from series when role-specific creators are empty)

  // Content info
  summary     String?
  genre       String? // Comma-separated genres
  tags        String? // Comma-separated tags
  characters  String? // Comma-separated character names
  teams       String? // Comma-separated team names
  locations   String? // Comma-separated locations

  // Series info
  count       Int? // Total issues in series
  storyArc    String?
  seriesGroup String?

  // Reading info
  pageCount   Int?
  languageISO String?
  format      String? // "Issue" | "Volume" | "TPB" | "Omnibus" | etc.
  ageRating   String?

  // External IDs for API matching
  comicVineId   String?
  metronId      String?

  // Manga classification (smart chapter/volume detection)
  contentType     String?   // "chapter" | "volume" | "extra" | "omake" | "bonus"
  parsedVolume    String?   // Volume number parsed from filename (e.g., "5" from v5c12)
  parsedChapter   String?   // Chapter number parsed from filename (e.g., "12" from v5c12)

  // Series inheritance tracking (Series-Centric Architecture)
  seriesInherited Boolean  @default(false)  // True if metadata was inherited from Series
  lastInheritedAt DateTime?                  // When metadata was last inherited
  seriesSource    String   @default("comicinfo") // "comicinfo" | "manual" | "fuzzy" | "api"

  // Per-field source overrides (for multi-source metadata)
  // JSON: {"writer": "metron", "colorist": "comicvine", ...}
  fieldSourceOverrides String?

  // Tracking
  lastScanned DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  comic ComicFile @relation(fields: [comicId], references: [id], onDelete: Cascade)

  @@index([series])
  @@index([writer])
  @@index([publisher])
  @@index([year])
  @@index([issueNumberSort])
}

// =============================================================================
// Operation Logging (for Rollback)
// =============================================================================

model OperationLog {
  id          String   @id @default(cuid())
  timestamp   DateTime @default(now())
  operation   String // "rename" | "move" | "convert" | "delete" | "metadata_update"
  source      String // Original file path or state
  destination String? // New file path or state (null for deletes)
  status      String   @default("success") // "success" | "failed" | "rolled_back"
  reversible  Boolean  @default(true)
  metadata    String? // JSON string with additional operation details
  error       String? // Error message if failed

  // Batch relation (operations can be part of a batch)
  batchId String?
  batch   BatchOperation? @relation(fields: [batchId], references: [id], onDelete: SetNull)

  @@index([timestamp])
  @@index([operation])
  @@index([batchId])
}

// =============================================================================
// Batch Operations
// =============================================================================

model BatchOperation {
  id          String   @id @default(cuid())
  libraryId   String?
  type        String // "convert" | "rename" | "metadata_update" | "move" | "delete"
  status      String   @default("pending") // "pending" | "in_progress" | "completed" | "failed" | "paused" | "cancelled"

  // Progress tracking
  totalItems     Int      @default(0)
  completedItems Int      @default(0)
  failedItems    Int      @default(0)

  // Timing
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Last processed item (for resume capability)
  lastProcessedId   String?
  lastProcessedPath String?

  // Error summary
  errorSummary String? // JSON array of error summaries

  // Relations
  library    Library?       @relation(fields: [libraryId], references: [id], onDelete: SetNull)
  operations OperationLog[]

  @@index([status])
  @@index([libraryId])
  @@index([createdAt])
}

// =============================================================================
// Duplicate Detection
// =============================================================================

model DuplicateGroup {
  id        String   @id @default(cuid())
  series    String?
  number    String?
  reason    String // "same_hash" | "same_metadata" | "similar_filename"
  status    String   @default("pending") // "pending" | "resolved" | "dismissed"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Store file IDs as comma-separated string (SQLite doesn't have arrays)
  fileIds String // Comma-separated list of ComicFile IDs

  @@index([status])
  @@index([series])
}

// =============================================================================
// API Response Cache
// =============================================================================

model APICache {
  id           String   @id @default(cuid())
  cacheKey     String   @unique // MD5 hash of normalized source+endpoint+params
  source       String // "comicvine" | "metron"
  endpoint     String // e.g., "/search/volumes", "/issue/123"
  params       String // JSON of normalized query params
  response     String // JSON response body
  resultCount  Int? // Number of results (for search queries)
  createdAt    DateTime @default(now())
  expiresAt    DateTime // TTL-based expiration
  lastAccessed DateTime @default(now())
  accessCount  Int      @default(0)

  @@index([cacheKey])
  @@index([expiresAt])
  @@index([source, endpoint])
}

// =============================================================================
// Cache Statistics (optional, for monitoring)
// =============================================================================

model CacheStats {
  id            String   @id @default(cuid())
  date          DateTime // One record per day per source
  source        String // "comicvine" | "metron" | "all"
  hits          Int      @default(0)
  misses        Int      @default(0)
  staleHits     Int      @default(0) // Stale cache fallback hits
  bytesServed   Int      @default(0)
  apiCallsSaved Int      @default(0)

  @@unique([date, source]) // Composite unique: one record per day per source
  @@index([date])
  @@index([source])
}

// =============================================================================
// Series Cache (Hybrid: DB tracking + JSON file storage)
// =============================================================================

model SeriesCache {
  id            String   @id @default(cuid())
  source        String   // "comicvine" | "metron"
  sourceId      String   // External API series ID
  name          String   // Series name for quick lookup
  publisher     String?
  startYear     Int?
  issueCount    Int?

  // File references (relative to ~/.helixio/cache/series/)
  seriesFilePath  String   // Path to {source}/{seriesId}.json
  issuesFilePath  String?  // Path to {source}/{seriesId}_issues.json (optional)

  // Cache control
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  expiresAt     DateTime
  lastAccessed  DateTime @default(now())
  accessCount   Int      @default(0)

  // Status
  hasIssues     Boolean  @default(false)
  fileSize      Int      @default(0)  // Combined size in bytes for quota management

  @@unique([source, sourceId])
  @@index([source, name])
  @@index([expiresAt])
  @@index([lastAccessed])
}

// =============================================================================
// Metadata Jobs (Persistent Background Jobs)
// =============================================================================

model MetadataJob {
  id          String   @id @default(cuid())

  // Job state
  status      String   @default("options") // "options" | "initializing" | "series_approval" | "fetching_issues" | "file_review" | "applying" | "complete" | "cancelled" | "error"
  step        String   @default("options") // Current step in workflow

  // Job configuration
  fileIds     String   // JSON array of file IDs being processed
  options     String   @default("{}") // JSON of CreateSessionOptions

  // Session data (JSON blobs for complex structures)
  sessionData String?  // JSON of ApprovalSession (seriesGroups, fileChanges, etc.)

  // Progress tracking
  currentSeriesIndex Int @default(0)
  totalFiles      Int @default(0)
  processedFiles  Int @default(0)

  // Current progress snapshot (for real-time display on reconnect)
  currentProgressMessage String?
  currentProgressDetail  String?
  lastProgressAt         DateTime?

  // Queue tracking (for background worker)
  queuedAt              DateTime?  // When job was enqueued for processing
  processingStartedAt   DateTime?  // When worker started processing
  processingPhase       String?    // Current processing phase

  // Error tracking
  error       String?

  // Apply results (when complete)
  applyResult String?  // JSON of apply results

  // Timing
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  expiresAt   DateTime // Auto-cleanup after expiration

  // Relations
  logs        MetadataJobLog[]

  @@index([status])
  @@index([createdAt])
  @@index([expiresAt])
}

model MetadataJobLog {
  id        String   @id @default(cuid())
  jobId     String

  // Log entry
  step      String   // Which step this log belongs to
  message   String
  detail    String?
  type      String   @default("info") // "info" | "success" | "warning" | "error"

  // Timing
  timestamp DateTime @default(now())

  // Relations
  job       MetadataJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([jobId, step])
  @@index([timestamp])
}

// =============================================================================
// Library Scan Jobs (Full Library Scan)
// =============================================================================

model LibraryScanJob {
  id                 String   @id @default(cuid())
  libraryId          String
  library            Library  @relation(fields: [libraryId], references: [id], onDelete: Cascade)

  // Job state: queued -> discovering -> cleaning -> indexing -> linking -> covers -> complete
  status             String   @default("queued")  // queued|discovering|cleaning|indexing|linking|covers|complete|error|cancelled
  currentStage       String   @default("queued")
  currentMessage     String?
  currentDetail      String?

  // Progress counters
  discoveredFiles    Int      @default(0)
  orphanedFiles      Int      @default(0)
  indexedFiles       Int      @default(0)
  linkedFiles        Int      @default(0)
  seriesCreated      Int      @default(0)
  coversExtracted    Int      @default(0)
  totalFiles         Int      @default(0)

  // Error tracking
  error              String?
  errorCount         Int      @default(0)

  // Timing
  queuedAt           DateTime @default(now())
  startedAt          DateTime?
  completedAt        DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  logs               LibraryScanJobLog[]

  @@index([libraryId])
  @@index([status])
  @@index([createdAt])
}

model LibraryScanJobLog {
  id        String   @id @default(cuid())
  jobId     String
  job       LibraryScanJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  stage     String
  message   String
  detail    String?
  type      String   @default("info")  // info|success|warning|error
  timestamp DateTime @default(now())

  @@index([jobId])
  @@index([stage])
}

// =============================================================================
// Reading Progress (Comic Reader)
// =============================================================================

model ReadingProgress {
  id           String    @id @default(cuid())
  fileId       String    @unique
  file         ComicFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  currentPage  Int       @default(0)
  totalPages   Int       @default(0)
  completed    Boolean   @default(false)
  lastReadAt   DateTime  @updatedAt
  bookmarks    String    @default("[]") // JSON array of page indices
  createdAt    DateTime  @default(now())

  @@index([lastReadAt])
  @@index([completed])
}

// =============================================================================
// Reader Settings (User Preferences)
// =============================================================================

model ReaderSettings {
  id              String  @id @default("default")
  mode            String  @default("single") // "single" | "double" | "doubleManga" | "continuous"
  direction       String  @default("ltr")    // "ltr" | "rtl" | "vertical"
  scaling         String  @default("fitHeight") // "fitHeight" | "fitWidth" | "fitScreen" | "original" | "custom"
  customWidth     Int?    // Custom width in pixels (when scaling = "custom")
  splitting       String  @default("none")   // "none" | "ltr" | "rtl"
  background      String  @default("black")  // "white" | "gray" | "black"
  brightness      Int     @default(100)      // 0-200, 100 is normal
  colorCorrection String  @default("none")   // "none" | "sepia-correct" | "contrast-boost" | "desaturate" | "invert"
  showPageShadow  Boolean @default(true)
  autoHideUI      Boolean @default(true)
  preloadCount    Int     @default(3)        // Number of pages to preload ahead
  webtoonGap      Int     @default(8)        // Gap between pages in webtoon mode (px)
  webtoonMaxWidth Int     @default(800)      // Max width for webtoon images (px)
  updatedAt       DateTime @updatedAt
}

// =============================================================================
// Library-Level Reader Settings (Overrides global defaults)
// =============================================================================

model LibraryReaderSettings {
  id              String   @id @default(cuid())
  libraryId       String   @unique
  library         Library  @relation(fields: [libraryId], references: [id], onDelete: Cascade)

  // All fields are optional - only set values override the global defaults
  mode            String?  // "single" | "double" | "doubleManga" | "continuous"
  direction       String?  // "ltr" | "rtl" | "vertical"
  scaling         String?  // "fitHeight" | "fitWidth" | "fitScreen" | "original" | "custom"
  customWidth     Int?
  splitting       String?  // "none" | "ltr" | "rtl"
  background      String?  // "white" | "gray" | "black"
  brightness      Int?
  colorCorrection String?  // "none" | "sepia-correct" | "contrast-boost" | "desaturate" | "invert"
  showPageShadow  Boolean?
  autoHideUI      Boolean?
  preloadCount    Int?
  webtoonGap      Int?
  webtoonMaxWidth Int?

  // Origin tracking (informational - tracks which preset these settings came from)
  basedOnPresetId   String?
  basedOnPresetName String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// =============================================================================
// Series-Level Reader Settings (Overrides library and global defaults)
// =============================================================================

model SeriesReaderSettings {
  id              String   @id @default(cuid())
  series          String   @unique  // Series name from metadata

  // All fields are optional - only set values override the inherited defaults
  mode            String?  // "single" | "double" | "doubleManga" | "continuous"
  direction       String?  // "ltr" | "rtl" | "vertical"
  scaling         String?  // "fitHeight" | "fitWidth" | "fitScreen" | "original" | "custom"
  customWidth     Int?
  splitting       String?  // "none" | "ltr" | "rtl"
  background      String?  // "white" | "gray" | "black"
  brightness      Int?
  colorCorrection String?  // "none" | "sepia-correct" | "contrast-boost" | "desaturate" | "invert"
  showPageShadow  Boolean?
  autoHideUI      Boolean?
  preloadCount    Int?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([series])
}

// =============================================================================
// Reading Queue (Sequential reading list)
// =============================================================================

model ReadingQueue {
  id        String    @id @default(cuid())
  fileId    String    @unique
  file      ComicFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  position  Int       // Order in queue (0 = next up)
  addedAt   DateTime  @default(now())

  @@index([position])
}

// =============================================================================
// Reading History (Individual reading sessions)
// =============================================================================

model ReadingHistory {
  id          String    @id @default(cuid())
  fileId      String
  file        ComicFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  startedAt   DateTime  @default(now())
  endedAt     DateTime?
  startPage   Int       @default(0)
  endPage     Int       @default(0)
  pagesRead   Int       @default(0)   // Calculated pages read in session
  duration    Int       @default(0)   // Duration in seconds
  completed   Boolean   @default(false) // Did user complete the comic?

  @@index([fileId])
  @@index([startedAt])
}

// =============================================================================
// Reading Statistics (Aggregated daily stats)
// =============================================================================

model ReadingStats {
  id              String   @id @default(cuid())
  date            DateTime // One record per day
  comicsStarted   Int      @default(0)
  comicsCompleted Int      @default(0)
  pagesRead       Int      @default(0)
  totalDuration   Int      @default(0)  // Total reading time in seconds
  sessionsCount   Int      @default(0)

  @@unique([date])
  @@index([date])
}

// =============================================================================
// User Accounts (Phase 9)
// =============================================================================

model User {
  id            String   @id @default(cuid())
  username      String   @unique
  email         String?  @unique
  passwordHash  String
  displayName   String?
  avatarUrl     String?
  role          String   @default("user") // "admin" | "user" | "guest"
  isActive      Boolean  @default(true)

  // Privacy settings
  profilePrivate    Boolean @default(false)
  hideReadingStats  Boolean @default(false)

  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastLoginAt   DateTime?

  // Relations
  sessions        UserSession[]
  libraryAccess   UserLibraryAccess[]
  readingProgress UserReadingProgress[]
  seriesProgress  SeriesProgress[]
  collections     Collection[]
  sharedLists     SharedReadingList[]
  trackerTokens   TrackerToken[]
  syncTokens      SyncToken[]
  readerPresets   ReaderPreset[]
  apiKeys         ApiKey[]

  @@index([username])
  @@index([email])
  @@index([role])
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token        String   @unique
  userAgent    String?
  ipAddress    String?
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  lastActiveAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model UserLibraryAccess {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  libraryId   String
  permission  String   @default("read") // "read" | "write" | "admin"
  createdAt   DateTime @default(now())

  @@unique([userId, libraryId])
  @@index([userId])
  @@index([libraryId])
}

model AppSettings {
  id                      String   @id @default("default")
  allowOpenRegistration   Boolean  @default(false)
  updatedAt               DateTime @updatedAt
}

model UserReadingProgress {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  fileId      String
  file        ComicFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  currentPage Int       @default(0)
  totalPages  Int       @default(0)
  completed   Boolean   @default(false)
  rating      Int?      // 1-5 stars
  bookmarks   String    @default("[]") // JSON array of page indices
  lastReadAt  DateTime  @updatedAt
  createdAt   DateTime  @default(now())

  @@unique([userId, fileId])
  @@index([userId])
  @@index([fileId])
  @@index([lastReadAt])
  @@index([completed])
}

// =============================================================================
// Shared Reading Lists (Phase 9)
// =============================================================================

model SharedReadingList {
  id          String   @id @default(cuid())
  ownerId     String
  owner       User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  name        String
  description String?
  isPublic    Boolean  @default(false)
  shareCode   String?  @unique // For private sharing via link
  items       String   // JSON array of { fileId, order, notes }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([ownerId])
  @@index([shareCode])
  @@index([isPublic])
}

// =============================================================================
// External Tracker Integration (Phase 10)
// =============================================================================

model TrackerToken {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  service      String   // "myanimelist" | "anilist" | "kitsu"
  accessToken  String
  refreshToken String?
  expiresAt    DateTime?
  scope        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([userId, service])
  @@index([userId])
}

model TrackerMapping {
  id            String   @id @default(cuid())
  series        String   // Local series name
  service       String   // "myanimelist" | "anilist" | "kitsu"
  externalId    String   // ID on external service
  externalTitle String?
  syncEnabled   Boolean  @default(true)
  lastSyncAt    DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([series, service])
  @@index([series])
  @@index([service])
}

// =============================================================================
// Cloud Sync (Phase 10)
// =============================================================================

model SyncToken {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceId     String
  deviceName   String?
  lastSyncAt   DateTime @default(now())
  syncVersion  Int      @default(0)
  createdAt    DateTime @default(now())

  @@unique([userId, deviceId])
  @@index([userId])
}

model SyncChange {
  id           String   @id @default(cuid())
  entityType   String   // "progress" | "bookmark" | "annotation" | "settings"
  entityId     String
  changeType   String   // "create" | "update" | "delete"
  changeData   String   // JSON of changed fields
  version      Int
  userId       String
  timestamp    DateTime @default(now())

  @@index([userId, version])
  @@index([entityType, entityId])
  @@index([timestamp])
}

// =============================================================================
// Cross-Source Metadata Mappings
// =============================================================================

model CrossSourceMapping {
  id              String   @id @default(cuid())

  // Primary source (the one user selected or searched from)
  primarySource   String   // 'comicvine' | 'metron' | 'gcd'
  primarySourceId String   // External API series ID for primary source

  // Matched source (the secondary source that was matched)
  matchedSource   String   // 'comicvine' | 'metron' | 'gcd'
  matchedSourceId String   // External API series ID for matched source

  // Match metadata
  confidence      Float    // 0.0 - 1.0 confidence score
  matchMethod     String   // 'auto' | 'user' | 'api_link'
  verified        Boolean  @default(false) // User has confirmed this mapping

  // Match factors (JSON for debugging/display)
  matchFactors    String?  // JSON: {"titleSimilarity": 0.95, "yearMatch": "exact", ...}

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([primarySource, primarySourceId, matchedSource])
  @@index([matchedSource, matchedSourceId])
  @@index([primarySource, primarySourceId])
}

// =============================================================================
// Comprehensive Stats System
// =============================================================================

// Entity Stats - Aggregated stats per metadata entity (creators, genres, characters, etc.)
model EntityStat {
  id            String   @id @default(cuid())

  // Entity identification
  entityType    String   // "creator" | "genre" | "character" | "team" | "publisher"
  entityName    String   // Exact name as stored in metadata
  entityRole    String?  // For creators: "writer" | "penciller" | etc. Null for others

  // Scope (null libraryId = user-level aggregate across all libraries)
  libraryId     String?
  library       Library? @relation(fields: [libraryId], references: [id], onDelete: Cascade)

  // Owned stats (collection)
  ownedComics   Int      @default(0)
  ownedSeries   Int      @default(0)
  ownedPages    Int      @default(0)

  // Read stats (reading progress)
  readComics    Int      @default(0)
  readPages     Int      @default(0)
  readTime      Int      @default(0)  // seconds

  // Timestamps
  updatedAt     DateTime @updatedAt

  @@unique([entityType, entityName, entityRole, libraryId])
  @@index([entityType, libraryId])
  @@index([libraryId])
  @@index([entityType, ownedComics])
  @@index([entityType, readComics])
  @@index([entityType, readTime])
}

// Library Stats - Cached library-level aggregates
model LibraryStat {
  id              String   @id @default(cuid())
  libraryId       String   @unique
  library         Library  @relation(fields: [libraryId], references: [id], onDelete: Cascade)

  // Collection stats
  totalFiles      Int      @default(0)
  totalSeries     Int      @default(0)
  totalPages      Int      @default(0)

  // Reading stats
  filesRead       Int      @default(0)
  filesInProgress Int      @default(0)
  filesUnread     Int      @default(0)
  pagesRead       Int      @default(0)
  readingTime     Int      @default(0)  // seconds

  // Metadata coverage
  filesWithMetadata Int    @default(0)

  updatedAt       DateTime @updatedAt
}

// Stats Dirty Flag - Track what needs recalculation
model StatsDirtyFlag {
  id          String   @id @default(cuid())

  // What's dirty
  scope       String   // "library" | "entity" | "user"
  scopeId     String?  // libraryId for library scope, null for user
  entityType  String?  // For entity scope: "creator" | "genre" | etc.
  entityName  String?  // For entity scope: specific entity name

  // Why it's dirty
  reason      String   // "metadata_change" | "reading_progress" | "file_added" | "file_removed"

  createdAt   DateTime @default(now())

  @@index([scope, scopeId])
  @@index([createdAt])
}

// User Stats - User-level aggregates (cross-library)
model UserStat {
  id              String   @id @default(cuid())

  // Collection stats (sum of all libraries)
  totalFiles      Int      @default(0)
  totalSeries     Int      @default(0)
  totalPages      Int      @default(0)

  // Reading stats
  filesRead       Int      @default(0)
  filesInProgress Int      @default(0)
  pagesRead       Int      @default(0)
  readingTime     Int      @default(0)

  // Streaks (cached from ReadingStats)
  currentStreak   Int      @default(0)
  longestStreak   Int      @default(0)

  updatedAt       DateTime @updatedAt
}

// =============================================================================
// Achievement System
// =============================================================================

// Achievement Definition - All possible achievements
model Achievement {
  id          String   @id @default(cuid())
  key         String   @unique  // Unique identifier e.g., "pages_100", "streak_7"
  name        String   // Display name
  description String   // Description of how to unlock
  category    String   // Category grouping
  stars       Int      // 1-5 star rating (difficulty/prestige)
  iconName    String   // Icon identifier for frontend
  threshold   Int?     // Numeric threshold for progress-based achievements
  minRequired Int?     // Minimum requirement (e.g., min library size for percentage achievements)
  createdAt   DateTime @default(now())

  // Relations
  userAchievements UserAchievement[]

  @@index([category])
  @@index([stars])
}

// User Achievement - Tracks user's progress and unlocks
model UserAchievement {
  id            String    @id @default(cuid())
  achievementId String
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  // Progress tracking
  progress      Int       @default(0)  // Current progress toward threshold
  unlockedAt    DateTime? // Null if not yet unlocked
  notified      Boolean   @default(false) // Whether user was notified of unlock

  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([achievementId]) // One record per achievement per user
  @@index([unlockedAt])
}

// =============================================================================
// Tag Autocomplete Cache
// =============================================================================

model TagValue {
  id         String   @id @default(cuid())
  fieldType  String   // "characters" | "teams" | "locations" | "genres" | "tags" | "storyArcs" | "publishers" | "writers" | "pencillers" | "inkers" | "colorists" | "letterers" | "coverArtists" | "editors"
  value      String   // The actual tag value
  valueLower String   // Lowercase version for case-insensitive prefix search

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([fieldType, value])
  @@index([fieldType, valueLower])
  @@index([fieldType])
}

// =============================================================================
// Collections (User Collections + System Collections)
// =============================================================================

model Collection {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  description String?
  deck        String?  // Short tagline/subtitle for the collection

  // System collection flag (Favorites, Want to Read)
  isSystem    Boolean  @default(false)
  systemKey   String?  // "favorites" | "want-to-read" | null for user collections

  // Ordering
  sortOrder   Int      @default(0)  // For custom ordering in UI

  // ===========================================
  // Lock flags for metadata fields
  // ===========================================
  lockName         Boolean @default(false)
  lockDeck         Boolean @default(false)
  lockDescription  Boolean @default(false)
  lockPublisher    Boolean @default(false)
  lockStartYear    Boolean @default(false)
  lockEndYear      Boolean @default(false)
  lockGenres       Boolean @default(false)

  // ===========================================
  // User collection metadata
  // ===========================================
  rating       Int?                          // 1-5 star rating
  notes        String?                       // Private notes/reminders
  visibility   String    @default("private") // "public", "private", "unlisted"
  readingMode  String?                       // Preferred reader mode: "single", "double", "webtoon"
  tags         String?                       // Comma-separated tags for filtering

  // ===========================================
  // Promotion (show in Series view)
  // ===========================================
  isPromoted    Boolean   @default(false)  // Show in Series page grid
  promotedOrder Int?                        // Sort order among promoted collections

  // ===========================================
  // Cover customization
  // ===========================================
  coverType     String    @default("auto")  // "auto" | "series" | "issue" | "custom"
  coverSeriesId String?                     // If coverType = "series", the series ID for cover
  coverFileId   String?                     // If coverType = "issue", the file ID for cover
  coverHash     String?                     // If coverType = "custom", hash of uploaded image

  // ===========================================
  // Auto-derived metadata cache (for promoted display)
  // ===========================================
  derivedPublisher   String?  // Most common publisher in collection
  derivedStartYear   Int?     // Earliest year from contained series
  derivedEndYear     Int?     // Latest year from contained series
  derivedGenres      String?  // Comma-separated aggregated genres
  derivedTags        String?  // Comma-separated aggregated tags from child series
  derivedIssueCount  Int?     // Total issues across all series
  derivedReadCount   Int?     // Total issues read across all series (user-specific)

  // ===========================================
  // Manual metadata overrides (null = use derived)
  // ===========================================
  overridePublisher  String?
  overrideStartYear  Int?
  overrideEndYear    Int?
  overrideGenres     String?

  // When derived metadata was last calculated
  metadataUpdatedAt  DateTime?

  // Most recent updatedAt from any contained series (for "Recently Updated" sort)
  contentUpdatedAt   DateTime?

  // ===========================================
  // Smart Collections
  // ===========================================
  isSmart           Boolean   @default(false)  // Whether this is a smart/dynamic collection
  smartScope        String?                     // "series" | "files" - what entities the filter applies to
  filterDefinition  String?                     // JSON string containing the SmartFilter definition
  lastEvaluatedAt   DateTime?                   // When the smart collection was last refreshed

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  items       CollectionItem[]

  @@unique([userId, systemKey])  // Each user gets their own system collections
  @@index([userId])
  @@index([isSystem])
  @@index([sortOrder])
  @@index([isPromoted])
  @@index([promotedOrder])
  @@index([userId, isPromoted])  // Efficient query for promoted collections per user
  @@index([isSmart])             // Efficient query for smart collections
}

model CollectionItem {
  id           String     @id @default(cuid())
  collectionId String
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  // Hybrid item support: either seriesId OR fileId (never both)
  seriesId     String?
  fileId       String?

  // Ordering within collection
  position     Int        @default(0)

  // Metadata
  addedAt      DateTime   @default(now())
  notes        String?    // Optional user notes about this item

  // Availability tracking (false if referenced file/series is deleted)
  isAvailable  Boolean    @default(true)

  // Smart collection membership overrides
  isWhitelisted Boolean   @default(false)  // Manually included in smart collection even if filter doesn't match
  isBlacklisted Boolean   @default(false)  // Manually excluded from smart collection even if filter matches

  @@unique([collectionId, seriesId])
  @@unique([collectionId, fileId])
  @@index([collectionId])
  @@index([seriesId])
  @@index([fileId])
  @@index([position])
}

// =============================================================================
// Reader Presets (Named Settings Configurations)
// =============================================================================

model ReaderPreset {
  id              String   @id @default(cuid())
  name            String
  description     String?
  icon            String?  // Emoji or icon name (e.g., "book", "scroll", "smartphone")

  // Ownership & Type
  userId          String?  // Null = system preset, non-null = user preset
  isSystem        Boolean  @default(false)  // Shared system preset (admin only)
  isBundled       Boolean  @default(false)  // Bundled preset (undeletable)

  // All settings fields (full copy)
  mode            String   @default("single")     // "single" | "double" | "doubleManga" | "continuous"
  direction       String   @default("ltr")        // "ltr" | "rtl" | "vertical"
  scaling         String   @default("fitHeight")  // "fitHeight" | "fitWidth" | "fitScreen" | "original" | "custom"
  customWidth     Int?
  splitting       String   @default("none")       // "none" | "ltr" | "rtl"
  background      String   @default("black")      // "white" | "gray" | "black"
  brightness      Int      @default(100)          // 0-200, 100 is normal
  colorCorrection String   @default("none")       // "none" | "sepia-correct" | "contrast-boost" | "desaturate" | "invert"
  showPageShadow  Boolean  @default(true)
  autoHideUI      Boolean  @default(true)
  preloadCount    Int      @default(3)            // Number of pages to preload
  webtoonGap      Int      @default(8)            // Gap between pages in webtoon mode (px)
  webtoonMaxWidth Int      @default(800)          // Max width for webtoon images (px)

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([name, userId])  // Unique name per user (or per system if userId is null)
  @@index([userId])
  @@index([isSystem])
  @@index([isBundled])
}

// =============================================================================
// Download Jobs (Background file downloads)
// =============================================================================

model DownloadJob {
  id              String    @id @default(cuid())
  userId          String    // User who requested the download

  // Job type and targets
  type            String    // "single" | "series" | "bulk"
  seriesId        String?   // For series downloads
  fileIds         String    // JSON array of file IDs
  contentHash     String?   // Hash of sorted file IDs for cache reuse

  // Job state
  status          String    @default("pending") // "pending" | "preparing" | "ready" | "downloading" | "completed" | "failed" | "expired" | "cancelled"

  // Progress tracking
  totalFiles      Int       @default(0)
  processedFiles  Int       @default(0)
  totalSizeBytes  BigInt    @default(0)   // Estimated total size
  skippedFiles    Int       @default(0)   // Files that couldn't be added (missing, locked)
  skippedFileIds  String?   // JSON array of skipped file IDs with reasons

  // Output
  outputPath      String?   // Path to generated ZIP file(s)
  outputParts     String?   // JSON array of part paths if split
  outputFileName  String?   // User-friendly filename
  outputSizeBytes BigInt?   // Actual output size

  // Splitting
  splitEnabled    Boolean   @default(false)
  splitSizeBytes  BigInt?   // Size threshold per part (e.g., 2GB)

  // Error tracking
  error           String?

  // Timestamps
  createdAt       DateTime  @default(now())
  startedAt       DateTime?
  completedAt     DateTime?
  expiresAt       DateTime? // When prepared files should be deleted (24h after completion)

  @@index([userId])
  @@index([status])
  @@index([expiresAt])
  @@index([seriesId])
  @@index([contentHash])
}

// =============================================================================
// Issue-Level Reader Settings (4th level of hierarchy)
// =============================================================================

model IssueReaderSettings {
  id               String    @id @default(cuid())
  fileId           String    @unique
  file             ComicFile @relation(fields: [fileId], references: [id], onDelete: Cascade)

  // All fields optional - only set values override parent (series/library/global)
  mode             String?   // "single" | "double" | "doubleManga" | "continuous"
  direction        String?   // "ltr" | "rtl" | "vertical"
  scaling          String?   // "fitHeight" | "fitWidth" | "fitScreen" | "original" | "custom"
  customWidth      Int?
  splitting        String?   // "none" | "ltr" | "rtl"
  background       String?   // "white" | "gray" | "black"
  brightness       Int?
  colorCorrection  String?   // "none" | "sepia-correct" | "contrast-boost" | "desaturate" | "invert"
  showPageShadow   Boolean?
  autoHideUI       Boolean?
  preloadCount     Int?
  webtoonGap       Int?
  webtoonMaxWidth  Int?

  // Origin tracking (informational - tracks which preset these settings came from)
  basedOnPresetId   String?
  basedOnPresetName String?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([fileId])
}

// =============================================================================
// Filename Templates
// =============================================================================

model FilenameTemplate {
  id              String   @id @default(cuid())
  libraryId       String?  // null = global template
  name            String
  description     String?
  filePattern     String   // Template pattern like "{Series} - {Number:000}.{Extension}"
  folderSegments  String   @default("[]") // JSON array of folder segment patterns
  characterRules  String   @default("{}") // JSON object for character replacement rules
  isActive        Boolean  @default(false)
  sortOrder       Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([libraryId, name])
  @@index([libraryId])
  @@index([isActive])
}
